'use strict'
const exec = require('child_process').exec
const AWS = require("aws-sdk")
const fs = require("fs")

const ddb = new AWS.DynamoDB()
const ssm = new AWS.SSM()
const sm = new AWS.SecretsManager()

var config = {
    "DDBForCerts": "",
    "certExpiryInDays": 30,
    "serverCertDDBKeyName": "_servercrt",
    "serverKeyDDBKeyName": "_serverkey",
    "certPassSecret": "",
    "userId": "",
    "forceCreateNewUserCert": false,
    "writeConsoleLog": false
}

process.env['PATH'] = process.env['PATH'] + ':' + process.env['LAMBDA_TASK_ROOT']

/*-------------------------------------------------------------------*/
// Set the config object
/*-------------------------------------------------------------------*/
exports.loadConfig = function (configIn) {
    for (const key of Object.keys(configIn)) {
        if (configIn[key]) {
            config[key] = configIn[key]
        }
    }
    writeConsoleLog("Config is : " + JSON.stringify(config, null, 2))
}

/*-------------------------------------------------------------------*/
// Method to generate server cert and key if required
exports.generateServerCert = async function () {
    var response = {
        "statusCode": 200,
        "body": {}
    }
    try {
        var certData = {}

        if (!config.forceCreate) {
            try {
                certData = await getDataFromDDB("")
            } catch (ddbGetError) {
                config.forceCreate = true
            }
        }


        if (config.forceCreate) {
            var certPass = await getSecretValue(config.certPassSecret)
            await executeOpenSSL(`openssl req -x509 -newkey rsa:2048 -keyout /tmp/servertmp.key -out /tmp/server.crt -nodes -days 365 -subj "${config.subject}"`)
            await executeOpenSSL(`openssl req -newkey rsa:2048 -keyout /tmp/usertmp.key -out /tmp/user.csr -nodes -days 365 -subj "/CN=${config.sampleUser}"`)
            await executeOpenSSL(`openssl x509 -req -in /tmp/user.csr -CA /tmp/server.crt -CAkey /tmp/servertmp.key -out /tmp/user.crt -set_serial 01 -days 365`)
            await executeOpenSSL(`openssl rsa -aes256 -in /tmp/servertmp.key -out /tmp/server.key -passout pass:${certPass}`)

            await writeDataToDDB(config.serverCertDDBKeyName, fs.readFileSync("/tmp/server.crt",{encoding:'utf8'}))
            await writeDataToDDB(config.serverKeyDDBKeyName, fs.readFileSync("/tmp/server.key",{encoding:'utf8'}))

            await executeOpenSSL('rm /tmp/servertmp.key /tmp/server.key /tmp/usertmp.key /tmp/user.csr ')
        } else {
            fs.writeFileSync("/tmp/server.key", certData.serverKey)
            fs.writeFileSync("/tmp/server.crt", certData.serverCert)
            await executeOpenSSL(`openssl req -newkey rsa:2048 -keyout /tmp/usertmp.key -out /tmp/user.csr -nodes -days 365 -subj "${config.sampleUser}"`)
            await executeOpenSSL(`openssl x509 -req -in /tmp/user.csr -CA /tmp/server.crt -CAkey /tmp/server.key -passin pass:${certPass} out /tmp/user.crt -set_serial 01 -days 2`)
        }
        var payload = {}
        payload.serverCert = fs.readFileSync("/tmp/server.crt",{encoding:'utf8'})
        payload.userCert = fs.readFileSync("/tmp/user.crt",{encoding:'utf8'})
        await executeOpenSSL('rm /tmp/server.crt /tmp/user.crt')

        response.body = payload

    } catch (functionError) {
        console.log("Error is " ,JSON.stringify(functionError))
        response.body = "Function Error, check console logs in cloudwatch"
    }

    return response

}
/*-------------------------------------------------------------------*/

/*-------------------------------------------------------------------*/
// Main method - Generate user certificate. Create a new one if one doesn't exist
// If one exists, retrieve from DynamoDB table and check if it is still valid (not expired)
// If expired, then recreate a new one
/*-------------------------------------------------------------------*/
exports.generateCert = async function () {
    var response = {
        "success": false,
        "payload": {}
    }
    try {
        //Check if the config object is correct set
        writeConsoleLog("...Checking Config")
        checkConfig()
        writeConsoleLog("...Config in good shape")

        // Get certificate secret key from secrets manager
        var certPass = await getSecretValue(config.certPassSecret)
        writeConsoleLog("...Received secret from secrets manager")

        // Create or Get the user certificate
        var userCertJson = {}
        var certData = {}
        if (config.forceCreateNewUserCert) {
            certData = await getDataFromDDB("")
            userCertJson = await createCertForUser(certPass, certPass, certData.serverKey, certData.serverCert)
            writeConsoleLog("...Created Cert for the User")
        } else {
            // Check if the user certificate already exists
            writeConsoleLog("Getting user cert from dynamodb table")
            //Get cert data from DDB
            certData = await getDataFromDDB(config.userId)
            if (certData.userCertJson && certData.userCertJson != "") {
                userCertJson = JSON.parse(certData.userCertJson)
                var expireBy = new Date(JSON.parse(userCertJson.expireBy));
                var now = new Date();
                now.setDate(now.getDate() + 1)
                if (now > expireBy) {
                    writeConsoleLog("...User Certs expired, creating a new one")
                    userCertJson = await createCertForUser(certPass, certPass, certData.serverKey, certData.serverCert)
                }
            } else {
                writeConsoleLog("...User Certs doesn't exist. Create a new one")
                userCertJson = await createCertForUser(certPass, certPass, certData.serverKey, certData.serverCert)
            }
        }
        userCertJson.serverCert = Buffer.from(certData.serverCert).toString('base64')
        userCertJson.userKeyPass = certPass
        response.payload = userCertJson
        response.success = true
        return response

    } catch (functionError) {
        response.success = false
        if (functionError.message) {
            writeConsoleLog("Function Error : " + JSON.stringify(functionError.message))
            response.payload = functionError.message
        } else {
            writeConsoleLog("Function Error : " + JSON.stringify(functionError))
            response.payload = JSON.stringify(functionError)
        }
        writeConsoleLog("Response is " + JSON.stringify(response, null, 2))
        return response
    }
}

/*-------------------------------------------------------------------*/
// Run OPENSSL linux command to create the certs
/*-------------------------------------------------------------------*/
async function createCertForUser(userKeyPass, serverKeyPass, serverKey, serverCert) {
    try {
        const subject = "/CN=" + config.userId
        // Download serverKey and serverCert to local
        fs.writeFileSync("/tmp/server.key", serverKey)
        fs.writeFileSync("/tmp/server.crt", serverCert)


        // Create CSR for the user
        const csrCmd = "openssl req -newkey rsa:2048 -keyout /tmp/usertmp.key -out /tmp/user.csr -nodes -days " + config.certExpiryInDays + " -subj " + '"' + subject + '"'
        await executeOpenSSL(csrCmd)

        // Encrypt the user key using passphrase
        const encUserKeyCmd = "openssl rsa -aes256 -in /tmp/usertmp.key -out /tmp/user.key -passout pass:" + userKeyPass
        await executeOpenSSL(encUserKeyCmd)

        // Sign the user cert with server cert
        const signCsrCmd = "openssl x509 -req -in /tmp/user.csr -CA /tmp/server.crt -CAkey /tmp/server.key -passin pass:" + serverKeyPass + " -out /tmp/user.crt -set_serial 01 -days " + config.certExpiryInDays
        await executeOpenSSL(signCsrCmd)

        //Create a JSON content to write to DynamoDB
        var userCertJson = {}
        var now = new Date()
        userCertJson.expireBy = JSON.stringify(now.setDate(now.getDate() + config.certExpiryInDays))
        var certBuff = fs.readFileSync("/tmp/user.crt")
        userCertJson.cert = new Buffer(certBuff).toString('base64')
        var keyBuff = fs.readFileSync("/tmp/user.key")
        userCertJson.key = new Buffer(keyBuff).toString('base64')
        //Delete downloaded keys and certs
        const removeCertsCmd = "rm /tmp/server.key /tmp/server.crt /tmp/user.key /tmp/user.crt /tmp/usertmp.key /tmp/user.csr"
        await executeOpenSSL(removeCertsCmd)
        //Update in DB
        await writeDataToDDB(config.userId, JSON.stringify(userCertJson))
        return userCertJson
    } catch (functionError) {
        throw new Error(functionError);
    }
}

/*-------------------------------------------------------------------*/
// Get cert/key data from DynamoDB
/*-------------------------------------------------------------------*/
function getDataFromDDB(id) {
    return new Promise((resolve, reject) => {
        try {
            var requestItems = {}
            requestItems[config.DDBForCerts] = {
                Keys: [{
                        id: {
                            S: config.serverCertDDBKeyName
                        }
                    },
                    {
                        id: {
                            S: config.serverKeyDDBKeyName
                        }
                    },
                    {
                        id: {
                            S: id
                        }
                    }
                ]
            }
            var params = {
                RequestItems: requestItems
            }
            ddb.batchGetItem(params, (ddbGetError, data) => {
                if (ddbGetError) {
                    writeConsoleLog('Error in getting the cert data from dynamodb: ' + JSON.stringify(ddbGetError))
                    reject(ddbGetError)
                }else{
                    var responses = data.Responses[config.DDBForCerts]
                    var response = {}
                    responses.forEach((item, index, array) => {
                        switch (item.id.S) {
                            case config.serverCertDDBKeyName:
                                response.serverCert = item.content.S
                                break;
                            case config.serverKeyDDBKeyName:
                                response.serverKey = item.content.S
                                break;
                            case id:
                                response.userCertJson = item.content.S
                                break;
                            default:
                                break
                        }
                    })
                    resolve(response)
                }
               
            })
        } catch (functionError) {
            writeConsoleLog('Error in getting data from dynamodb : ' + JSON.stringify(functionError))
            reject(functionError)
        }
    })
}

/*-------------------------------------------------------------------*/
// Write cert/key data to DynamoDB
/*-------------------------------------------------------------------*/
function writeDataToDDB(id, content) {
    return new Promise((resolve, reject) => {
        try {
            var params = {
                TableName: config.DDBForCerts,
                Item: {
                    "id": {
                        S: id
                    },
                    "content": {
                        S: content
                    }
                }
            }
            ddb.putItem(params, (ddbPutError, data) => {
                if (ddbPutError) {
                    writeConsoleLog('Error in putting the cert data from dynamodb: ' + JSON.stringify(ddbPutError))
                    reject(ddbPutError)
                }
                resolve(data)
            })
        } catch (functionError) {
            writeConsoleLog('Error in writing data to dynamodb : ' + JSON.stringify(functionError))
            reject(functionError)
        }
    })
}


/*-------------------------------------------------------------------*/
//Execute OpenSSL Command
/*-------------------------------------------------------------------*/
function executeOpenSSL(command) {
    writeConsoleLog("Command is: " + command)
    return new Promise((resolve, reject) => {
        exec(command, (execError, stdout, stderr) => {
            try {
                if (execError) {
                    writeConsoleLog('stderr: ' + JSON.stringify(stderr))
                    writeConsoleLog('stdout: ' + JSON.stringify(stdout))
                    reject(execError)
                }
                writeConsoleLog('stdout: ' + JSON.stringify(stdout))
                resolve('executed')
            } catch (functionError) {
                writeConsoleLog('OpenSSL error: ' + JSON.stringify(functionError))
                reject(functionError)
            }
        })
    })

}

/*-------------------------------------------------------------------*/
// Get secrets from Secrets Manager
/*-------------------------------------------------------------------*/
function getSecretValue(secretName) {
    return new Promise((resolve, reject) => {
        try {
            var params = {
                SecretId: secretName
            };
            sm.getSecretValue(params, (err, data) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(data.SecretString);
                }
            });
        } catch (e) {
            reject(e);
        }
    });
}

/*-------------------------------------------------------------------*/
// Get secrets from Parameter store
/*-------------------------------------------------------------------*/
function getSecretsFromParameterStore(serverKeyPassParam, userKeyPassParam) {
    var response = {}
    response.serverKeyPass = ""
    response.userKeyPass = ""

    return new Promise((resolve, reject) => {
        try {
            var params = {
                Names: [serverKeyPassParam, userKeyPassParam],
                WithDecryption: true
            }
            ssm.getParameters(params, (paramsGetError, data) => {
                if (paramsGetError) {
                    reject(paramsGetError)
                }
                if (data.Parameters && Array.isArray(data.Parameters)) {
                    var parameters = data.Parameters
                    if (parameters.length == 2) {
                        parameters.forEach((parameter, index) => {
                            if (parameter.Name == serverKeyPassParam) {
                                response.serverKeyPass = parameter.Value
                            }
                            if (parameter.Name == userKeyPassParam) {
                                response.userKeyPass = parameter.Value
                            }
                        })
                        resolve(response)
                    } else {
                        reject('No enough parameters retrieved. Need two parameters')
                    }
                } else {
                    reject('No parameters retrieved')
                }

            })
        } catch (functionError) {
            reject(functionError)
        }

    })
}

/*-------------------------------------------------------------------*/
// Check if the config object is valid
/*-------------------------------------------------------------------*/
function checkConfig() {
    if (!config) {
        throw new Error("Config object cannot be null or undefined")
    }

    if (typeof config.DDBForCerts === 'undefined' || config.DDBForCerts === "") {
        throw new Error("DDBForCerts in config object cannot be null, empty or undefined")
    }
    if (typeof config.serverCertDDBKeyName === 'undefined' || config.serverCertDDBKeyName === "") {
        throw new Error("serverCertDDBKeyName in config object cannot be null, empty or undefined")
    }
    if (typeof config.serverKeyDDBKeyName === 'undefined' || config.serverKeyDDBKeyName === "") {
        throw new Error("serverKeyDDBKeyName in config object cannot be null, empty or undefined")
    }
    if (typeof config.certPassSecret === 'undefined' || config.certPassSecret === "") {
        throw new Error("certPassSecret in config object cannot be null, empty or undefined")
    }
    if (typeof config.userId === 'undefined' || config.userId === "") {
        throw new Error("userId in config object cannot be be null, empty or undefined")
    }
    if (typeof config.certExpiryInDays === 'undefined' || config.certExpiryInDays < 1) {
        throw new Error("certExpiryInDays in config object cannot be undefined or lesser than 1 day")
    }
}

/*-------------------------------------------------------------------*/
//Write console logs
/*-------------------------------------------------------------------*/
function writeConsoleLog(message) {
    if (config.writeConsoleLog) {
        console.log(message)
    }
}