'use strict'
const exec = require('child_process').exec
const AWS = require("aws-sdk")
const fs = require("fs")

const ddb = new AWS.DynamoDB()
const ssm = new AWS.SSM()
const sm = new AWS.SecretsManager()


process.env['PATH'] = process.env['PATH'] + ':' + process.env['LAMBDA_TASK_ROOT']

/*-------------------------------------------------------------------*/
// Method to generate server cert and key if required
/*-------------------------------------------------------------------*/
exports.generateServerCert = async function (configIn) {
    var response = {
        "statusCode": 200,
        "body": {}
    }
    try {
        var config = loadConfig(configIn)
        var fileNames = getFileNames(config)
        var certData = {}
        var cmd = ""
        if (!config.forceCreate) {
            try {
                certData = await getDataFromDDB("",config)
            } catch (ddbGetError) {
                config.forceCreate = true
            }
        }
        // Get passphrase for server secret
        var certPass = await getSecretValue(config.certPassSecret)
        if (config.forceCreate) {
            // Create Server cert and server key (temp)
            cmd = `openssl req -x509 -newkey rsa:2048 -keyout ${fileNames.serverKeyTmp} -out ${fileNames.serverCert} -nodes -days ${config.serverCertExpiryInDays} -subj "${config.subject}"`
            await executeCmd(config,cmd)

            // Create User CSR and user key (temp)
            cmd = `openssl req -newkey rsa:2048 -keyout ${fileNames.userKeyTmp} -out ${fileNames.userCsr} -nodes -days 1 -subj "/CN=${config.userId}"`
            await executeCmd(config,cmd)

            // Create User cert with a validity of 1 day and sign it with the server key
            cmd = `openssl x509 -req -in ${fileNames.userCsr} -CA ${fileNames.serverCert} -CAkey ${fileNames.serverKeyTmp} -out ${fileNames.userCert} -set_serial 01 -days 1`
            await executeCmd(config,cmd)

            // Encrypt the server key with a passphrase available from secrets manager
            cmd = `openssl rsa -aes256 -in ${fileNames.serverKeyTmp} -out ${fileNames.serverKey} -passout pass:${certPass}`
            await executeCmd(config,cmd)

            //Store the server key and server cert to DDB
            await writeDataToDDB(config.serverCertDDBKeyName, fs.readFileSync(`${fileNames.serverCert}`,{encoding:'utf8'}),config)
            await writeDataToDDB(config.serverKeyDDBKeyName, fs.readFileSync(`${fileNames.serverKey}`,{encoding:'utf8'}),config)
            
            //Remove all un-needed files
            await executeCmd(config,'ls -al') //debug
            cmd = `rm ${fileNames.serverKeyTmp}`
            await executeCmd(config,cmd)
            
        } else {
            fs.writeFileSync(`${fileNames.serverKey}`, certData.serverKey)
            fs.writeFileSync(`${fileNames.serverCert}`, certData.serverCert)

            // Create User CSR and user key (temp)
            cmd = `openssl req -newkey rsa:2048 -keyout ${fileNames.userKeyTmp} -out ${fileNames.userCsr} -nodes -days 1 -subj "/CN=${config.userId}"`
            await executeCmd(config,cmd)

            // Create User cert with a validity of 1 day and sign it with the server key
            cmd = `openssl x509 -req -in ${fileNames.userCsr} -CA ${fileNames.serverCert} -CAkey ${fileNames.serverKey}  -passin pass:${certPass} -out ${fileNames.userCert} -set_serial 01 -days 1`
            await executeCmd(config,cmd)

        }
        
        var payload = {}
        payload.serverCert = fs.readFileSync(`${fileNames.serverCert}`,{encoding:'utf8'})
        payload.userCert = fs.readFileSync(`${fileNames.userCert}`,{encoding:'utf8'})

        //Remove all un-needed files
        cmd = `rm ${fileNames.serverCert} ${fileNames.serverKey}`
        await executeCmd(config,cmd)

        cmd = `rm ${fileNames.userCert} ${fileNames.userKeyTmp} ${fileNames.userCsr}`
        await executeCmd(config,cmd)

        response.body = payload

    } catch (functionError) {
        writeConsoleLog(config,"Function Error " ,JSON.stringify(functionError))
        response.body = "Function Error, check console logs in cloudwatch"
    }

    return response

}


/*-------------------------------------------------------------------*/
// Main method - Generate user certificate. Create a new one if one doesn't exist
// If one exists, retrieve from DynamoDB table and check if it is still valid (not expired)
// If expired, then recreate a new one
/*-------------------------------------------------------------------*/
exports.generateCert = async function (configIn) {
    var response = {
        "success": false,
        "payload": {}
    }
    try {
        
        var config = loadConfig(configIn)
        var fileNames = getFileNames(config)

        // Get certificate secret key from secrets manager
        var certPass = await getSecretValue(config.certPassSecret)
        writeConsoleLog(config,"...Received secret from secrets manager")

        // Create or Get the user certificate
        var userCertJson = {}
        var certData = {}
        if (config.forceCreateNewUserCert) {
            certData = await getDataFromDDB("",config)
            userCertJson = await createCertForUser(config,certPass, certData.serverKey, certData.serverCert)
            writeConsoleLog(config,"...Created Cert for the User")
        } else {
            // Check if the user certificate already exists
            writeConsoleLog(config,"Getting user cert from dynamodb table")
            //Get cert data from DDB
            certData = await getDataFromDDB(config.userId, config)
            if (certData.userCertJson && certData.userCertJson != "") {
                userCertJson = JSON.parse(certData.userCertJson)
                var expireBy = new Date(JSON.parse(userCertJson.expireBy));
                var now = new Date();
                if (now > expireBy) {
                    writeConsoleLog(config,"...User Certs expired, creating a new one")
                    userCertJson = await createCertForUser(config,certPass, certData.serverKey, certData.serverCert)
                }
            } else {
                writeConsoleLog(config,"...User Certs doesn't exist. Create a new one")
                userCertJson = await createCertForUser(config,certPass, certData.serverKey, certData.serverCert)
            }
        }
        userCertJson.serverCert = Buffer.from(certData.serverCert).toString('base64')
        response.payload = userCertJson
        response.success = true
        return response

    } catch (functionError) {
        response.success = false
        if (functionError.message) {
            writeConsoleLog(config,"Function Error : " + JSON.stringify(functionError.message))
            response.payload = functionError.message
        } else {
            writeConsoleLog(config,"Function Error : " + JSON.stringify(functionError))
            response.payload = JSON.stringify(functionError)
        }
        writeConsoleLog(config,"Response is " + JSON.stringify(response, null, 2))
        return response
    }
}

/*-------------------------------------------------------------------*/
// Run OPENSSL linux command to create the certs
/*-------------------------------------------------------------------*/
async function createCertForUser(config,serverKeyPass, serverKey, serverCert) {
    try {
        var userKeyPass = uuidv4()
        var fileNames = getFileNames(config)
        // Download serverKey and serverCert to local
        fs.writeFileSync(`${fileNames.serverKey}`, serverKey)
        fs.writeFileSync(`${fileNames.serverCert}`, serverCert)

        var cmd = ""

        // Create User CSR and user key (temp)
        cmd = `openssl req -newkey rsa:2048 -keyout ${fileNames.userKeyTmp} -out ${fileNames.userCsr} -nodes -days 1 -subj "/CN=${config.userId}"`
        await executeCmd(config,cmd)

        // Encrypt the user key using passphrase
        cmd = `openssl rsa -aes256 -in ${fileNames.userKeyTmp} -out ${fileNames.userKey} -passout pass:${userKeyPass}`
        await executeCmd(config,cmd)

        // Sign the user cert with server cert
        cmd = `openssl x509 -req -in ${fileNames.userCsr} -CA ${fileNames.serverCert} -CAkey ${fileNames.serverKey} -passin pass:${serverKeyPass} -out ${fileNames.userCert} -set_serial 01 -days ${config.serverCertExpiryInDays}`
        await executeCmd(config,cmd)

        //Create a JSON content to write to DynamoDB
        var userCertJson = {}
        var now = new Date()
        userCertJson.expireBy = JSON.stringify(now.setDate(now.getDate()+1)) // One day validity
        userCertJson.userKeyPass = userKeyPass
        var certBuff = fs.readFileSync(`${fileNames.userCert}`)
        userCertJson.cert = new Buffer(certBuff).toString('base64')
        var keyBuff = fs.readFileSync(`${fileNames.userKey}`)
        userCertJson.key = new Buffer(keyBuff).toString('base64')
        
        //Delete downloaded keys and certs
        cmd = `rm ${fileNames.serverKey} ${fileNames.serverCert}`
        await executeCmd(config,cmd)

        cmd = `rm ${fileNames.userCsr} ${fileNames.userCert} ${fileNames.userKey} ${fileNames.userKeyTmp}`
        await executeCmd(config,cmd)

        //Update in DB
        await writeDataToDDB(config.userId, JSON.stringify(userCertJson),config)
        return userCertJson

    } catch (functionError) {
        throw new Error(functionError);
    }
}

/*-------------------------------------------------------------------*/
// Get cert/key data from DynamoDB
/*-------------------------------------------------------------------*/
function getDataFromDDB(id,config) {
    return new Promise((resolve, reject) => {
        try {
            var requestItems = {}
            requestItems[config.DDBForCerts] = {
                Keys: [{
                        id: {
                            S: config.serverCertDDBKeyName
                        }
                    },
                    {
                        id: {
                            S: config.serverKeyDDBKeyName
                        }
                    },
                    {
                        id: {
                            S: id
                        }
                    }
                ]
            }
            var params = {
                RequestItems: requestItems
            }
            ddb.batchGetItem(params, (ddbGetError, data) => {
                if (ddbGetError) {
                    writeConsoleLog(config,'Error in getting the cert data from dynamodb: ' + JSON.stringify(ddbGetError))
                    reject(ddbGetError)
                }else{
                    var responses = data.Responses[config.DDBForCerts]
                    var response = {}
                    responses.forEach((item, index, array) => {
                        switch (item.id.S) {
                            case config.serverCertDDBKeyName:
                                response.serverCert = item.content.S
                                break;
                            case config.serverKeyDDBKeyName:
                                response.serverKey = item.content.S
                                break;
                            case id:
                                response.userCertJson = item.content.S
                                break;
                            default:
                                break
                        }
                    })
                    resolve(response)
                }
               
            })
        } catch (functionError) {
            writeConsoleLog(config,'Error in getting data from dynamodb : ' + JSON.stringify(functionError))
            reject(functionError)
        }
    })
}

/*-------------------------------------------------------------------*/
// Write cert/key data to DynamoDB
/*-------------------------------------------------------------------*/
function writeDataToDDB(id, content,config) {
    return new Promise((resolve, reject) => {
        try {
            var params = {
                TableName: config.DDBForCerts,
                Item: {
                    "id": {
                        S: id
                    },
                    "content": {
                        S: content
                    }
                }
            }
            ddb.putItem(params, (ddbPutError, data) => {
                if (ddbPutError) {
                    writeConsoleLog(config,'Error in putting the cert data from dynamodb: ' + JSON.stringify(ddbPutError))
                    reject(ddbPutError)
                }
                resolve(data)
            })
        } catch (functionError) {
            writeConsoleLog(config,'Error in writing data to dynamodb : ' + JSON.stringify(functionError))
            reject(functionError)
        }
    })
}


/*-------------------------------------------------------------------*/
//Execute OpenSSL Command
/*-------------------------------------------------------------------*/
function executeCmd(config,command) {
    writeConsoleLog(config,"Command is: " + command)
    return new Promise((resolve, reject) => {
        exec(command, (execError, stdout, stderr) => {
            try {
                if (execError) {
                    writeConsoleLog(config,'stderr: ' + JSON.stringify(stderr))
                    writeConsoleLog(config,'stdout: ' + JSON.stringify(stdout))
                    reject(execError)
                }
                writeConsoleLog(config,'stdout: ' + JSON.stringify(stdout))
                resolve('executed')
            } catch (functionError) {
                writeConsoleLog(config,'OpenSSL error: ' + JSON.stringify(functionError))
                reject(functionError)
            }
        })
    })

}

/*-------------------------------------------------------------------*/
// Get secrets from Secrets Manager
/*-------------------------------------------------------------------*/
function getSecretValue(secretName) {
    return new Promise((resolve, reject) => {
        try {
            var params = {
                SecretId: secretName
            };
            sm.getSecretValue(params, (err, data) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(data.SecretString);
                }
            });
        } catch (e) {
            reject(e);
        }
    });
}


/*-------------------------------------------------------------------*/
// Init and load Config object
/*-------------------------------------------------------------------*/
function loadConfig(configIn){
    var config = {
        "DDBForCerts": "",
        "serverCertExpiryInDays": 365,
        "serverCertDDBKeyName": "_servercrt",
        "serverKeyDDBKeyName": "_serverkey",
        "certPassSecret": "",
        "userId": "",
        "forceCreateNewUserCert": false,
        "writeConsoleLog": false,
        "requestId" : ""
    }
    for (const key of Object.keys(configIn)) {
        if (configIn[key]) {
            config[key] = configIn[key]
        }
    }
    writeConsoleLog(config,"Config is : " + JSON.stringify(config, null, 2))
    //Check if the config object is valid
    checkConfig(config)
    return config
}

/*-------------------------------------------------------------------*/
//Get filenames [full path]
/*-------------------------------------------------------------------*/
function getFileNames(config){
    var fileNames = {}
    var targetFolder = '/tmp/'
    fileNames.serverKeyTmp = targetFolder + config.userId + '-' + config.requestId + '_servertmp.key'
    fileNames.serverKey = targetFolder + config.userId + '-' + config.requestId + '_server.key'
    fileNames.serverCert = targetFolder + config.userId + '-' + config.requestId + '_server.crt'
    fileNames.userKeyTmp = targetFolder + config.userId + '-' + config.requestId + '_usertmp.key'
    fileNames.userKey = targetFolder + config.userId + '-' + config.requestId + '_user.key'
    fileNames.userCert = targetFolder + config.userId + '-' + config.requestId + '_user.crt'
    fileNames.userCsr = targetFolder + config.userId + '-' + config.requestId + '_userCsr.key'
    return fileNames
}


/*-------------------------------------------------------------------*/
// Check if the config object is valid
/*-------------------------------------------------------------------*/
function checkConfig(config) {
    if (!config) {
        throw new Error("Config object cannot be null or undefined")
    }

    if (typeof config.DDBForCerts === 'undefined' || config.DDBForCerts === "") {
        throw new Error("DDBForCerts in config object cannot be null, empty or undefined")
    }
    if (typeof config.serverCertDDBKeyName === 'undefined' || config.serverCertDDBKeyName === "") {
        throw new Error("serverCertDDBKeyName in config object cannot be null, empty or undefined")
    }
    if (typeof config.serverKeyDDBKeyName === 'undefined' || config.serverKeyDDBKeyName === "") {
        throw new Error("serverKeyDDBKeyName in config object cannot be null, empty or undefined")
    }
    if (typeof config.certPassSecret === 'undefined' || config.certPassSecret === "") {
        throw new Error("certPassSecret in config object cannot be null, empty or undefined")
    }
    if (typeof config.userId === 'undefined' || config.userId === "") {
        throw new Error("userId in config object cannot be be null, empty or undefined")
    }
    if (typeof config.serverCertExpiryInDays === 'undefined' || config.serverCertExpiryInDays < 1) {
        throw new Error("serverCertExpiryInDays in config object cannot be undefined or lesser than 1 day")
    }
    if (typeof config.requestId === 'undefined' || config.certExpiryInDays === "") {
        config.requestId = uuidv4() // Get an unique id
    }
}

/*-------------------------------------------------------------------*/
//Get uuid
/*-------------------------------------------------------------------*/
function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  

/*-------------------------------------------------------------------*/
//Write console logs
/*-------------------------------------------------------------------*/
function writeConsoleLog(config,message) {
    if (config.writeConsoleLog) {
        console.log(message)
    }
}